// Generated by CoffeeScript 1.4.0
var connect, exec, fs, _ref;

connect = require('connect');

fs = require('fs');

if ((_ref = fs.exists) == null) {
  fs.exists = require('path').exists;
}

exec = require('child_process').exec;

/*
`dojo([options])`
-----------------

Connect middleware exposing the Dojo Toolkit.

By default, Dojo releases are downloaded and extracted 
inside the "/tmp" folder and are cached for later usages. 
You may change this folder into a permanent location by 
providing the option "repository".

Options include: 
*   method        One of "release" or "git"
*   version       Dojo version
*   repository    Caching folder, default to "/tmp"
*/


module.exports = function(options) {
  var args, count, dir, finish, loading, mapping, plugin, submodules, tgz, url, _finish, _ref1, _ref2, _ref3;
  if (options == null) {
    options = {};
  }
  if ((_ref1 = options.method) == null) {
    options.method = 'release';
  }
  if ((_ref2 = options.version) == null) {
    options.version = '1.8.3';
  }
  if ((_ref3 = options.repository) == null) {
    options.repository = '/tmp';
  }
  loading = true;
  submodules = ['dojo', 'dijit', 'dojox', 'util'];
  mapping = {};
  args = [];
  switch (options.method) {
    case 'release':
      tgz = "" + options.repository + "/dojo-release-" + options.version + ".tar.gz";
      dir = "" + options.repository + "/dojo-release-" + options.version;
      url = "http://download.dojotoolkit.org/release-" + options.version + "/dojo-release-" + options.version + ".tar.gz";
      mapping = {
        dojo: "" + dir + "/dojo",
        dijit: "" + dir + "/dijit",
        dojox: "" + dir + "/dojox",
        util: "" + dir + "/util"
      };
      fs.exists(dir, function(exists) {
        var cmd;
        if (exists) {
          return finish();
        }
        cmd = "curl " + url + " -o " + tgz + " && tar -xzf " + tgz + " -C " + options.repository;
        return exec(cmd, function(err, stdout, stderr) {
          if (err) {
            return finish(err);
          }
          return finish(err);
        });
      });
      break;
    case 'git':
      count = 0;
      _finish = function() {
        if (++count !== 4) {
          return;
        }
        return finish();
      };
      submodules.forEach(function(submodule) {
        var checkout, clone, dirname, revision;
        revision = options["" + submodule + "_revision"] || 'HEAD';
        dirname = "git-" + submodule + "-" + revision;
        mapping[submodule] = "" + options.repository + "/" + dirname;
        clone = function(next) {
          return fs.exists('#{options.repository}/#{dirname}', function(exists) {
            var cmds;
            if (exists && revision !== 'HEAD') {
              return _finish();
            }
            if (exists) {
              return next();
            }
            url = "https://github.com/dojo/" + submodule + ".git";
            cmds = [];
            cmds.push("cd " + options.repository);
            cmds.push("git clone " + url + " " + dirname);
            cmds = cmds.join(' && ');
            return exec(cmds, function(err, stdout, stderr) {
              return next(err);
            });
          });
        };
        checkout = function(next) {
          var cmds;
          cmds = [];
          cmds.push('cd #{options.repository}/#{dirname}');
          cmds.push("git checkout " + revision);
          cmds = cmds.join(' && ');
          return exec(cmds, function(err, stdout, stderr) {
            return next(err);
          });
        };
        return clone(function(err) {
          if (err) {
            return finish(err);
          }
          return checkout(function(err) {
            if (err) {
              return finish(err);
            }
            return _finish();
          });
        });
      });
      break;
    default:
      throw new Error("Invalid method option \"" + options.method + "\")");
  }
  finish = function(err) {
    var arg, _i, _len, _results;
    if (err) {
      throw err;
    }
    loading = false;
    _results = [];
    for (_i = 0, _len = args.length; _i < _len; _i++) {
      arg = args[_i];
      _results.push(plugin.apply(null, arg));
    }
    return _results;
  };
  plugin = function(req, res, next) {
    var app, sttc;
    if (loading) {
      return args.push(arguments);
    }
    app = /^\/(\w+)\/.*/.exec(req.url);
    if (app && submodules.indexOf(app[1]) !== -1) {
      app = app[1];
      req.url = req.url.substr(app.length + 1);
      sttc = connect["static"](mapping[app]);
      return sttc(req, res, function() {
        req.url = "/" + app + req.url;
        return next();
      });
    } else {
      return next();
    }
  };
  return plugin;
};
